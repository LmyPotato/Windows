///*给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。
//
//如果反转后整数超过 32 位的有符号整数的范围 [−231,  231 − 1] ，就返回 0。
//
//假设环境不允许存储 64 位整数（有符号或无符号）。
// 
//
//示例 1：
//
//输入：x = 123
//输出：321
//示例 2：
//
//输入：x = -123
//输出：-321
//示例 3：
//
//输入：x = 120
//输出：21
//示例 4：
//
//输入：x = 0
//输出：0
////1534236469
////1463847412 
//
//提示：
//
//-231 <= x <= 231 - 1
//1534236469
//来源：力扣（LeetCode）
//链接：https://leetcode-cn.com/problems/reverse-integer
//著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
//*/
//
//#include<iostream>
//
//using namespace std;
//
//class Solution {
//public:
//    int reverse(int x);
//};
///*
//刚开始的时候用到vector，认为边取余边除，然后再pushback进vector
//后面在网上发现多次一举，可以直接计算结果（感觉自己有点傻）
//*/
//int Solution::reverse(int x)
//{
//    int  ret=0;
//    while(x!=0)
//    {
//        /*
//        int最大数为：2147483642
//        为什么除了10
//
//        网上一位网友是这样子说的：
//
//        对数字先进行乘法再进行判断，就会超出int的取值范围。
//
//        换个思路：先判定，再进行乘法
//        当前数如果比int最大值除10，还要大，那么该数就一定会溢出。
//        当前数如果比int最小值除10，还要小，那么该数就一定会溢出。
//        */
//        if (ret >214748364|| ret < -214748364)
//        {
//            return 0;
//        }
//        ret=ret*10+x%10;
//        x=x/10;
//    }
//    return ret;
//}
//
//int main(){
//    Solution s;
//    int data=0;
//    int ret=0;
//
//    cin>>data;
//
//    ret=s.reverse(data);
//
//    cout<<"ret= "<<ret<<endl;
//
//    return 0;
//}
//
//

链表:

## 1.1 链表结构:

```cpp
struct ListNode {
    int val;
    struct ListNode *next;
    ListNode(){}
    ListNode(int num):val(num),next(nullptr){}
};
```

---

## 1.2 链表初始化:

```cpp
void listInit(ListNode *L)
{
    L = new ListNode(-1);
}
```

---

## 1.3  打印链表：

```cpp
void printList(ListNode *L)
{
    //L = L->next;
    while (L != nullptr) {
        cout<<L->val<<" ";
        L = L->next;
    }
    cout<<endl;
}
```

---

## 1.4 链表的创建(头插)：

![](https://gitee.com/lmypotato/Image/raw/master//img/CreateList_H.drawio.png)

```c
void createListByHead(ListNode *head, int n)
{
    int val = 0;
    int t = n;

    while (n--)
    {
        printf("请输入第%d个数:\n", t - n);
        cin >> val;
        ListNode *tmp = new ListNode(val);

        tmp->next = head->next;
        head->next = tmp;
    }
}
```



## 1.5 链表的创建(尾插)：

![CreateList_R.drawio](https://gitee.com/lmypotato/Image/raw/master//img/CreateList_R.drawio.png)

```cpp
void createList(ListNode *head, int n)
{
    ListNode *r = head;
    int val = 0;
    int t = n;

    while (n--) {
        printf("请输入第%d个数:\n",t - n);
        cin>>val;
        ListNode *tmp = new ListNode(val);
        r->next = tmp;
        r = tmp;
    }
}
```

---

## 1.6 链表的删除：

```cpp
void delList(ListNode *L, int index)
{
    while (index--) {
        L = L->next;
    }

    ListNode *tmp = L->next;
    L->next = tmp->next;

    delete tmp;
}
```

---

## 1.7 链表的插入：

```cpp
void insertList(ListNode *L, int index, int val)
{
    while (index--) {
        L = L->next;
    }

    ListNode *tmp = new ListNode(val);
    tmp->next = L->next;
    L->next = tmp;
}
```

---

## 1.8 链表的反转：

![listReverse](https://gitee.com/lmypotato/Image/raw/master//img/listReverse.jpg)

```cpp
ListNode* reverseList(ListNode *L)
{
    ListNode *pre = nullptr;
    ListNode *cur = L;

    while (cur != nullptr) {
        ListNode *tmp = cur->next;

        cur->next = pre;

        pre = cur;
        cur = tmp;
    }
    return pre;
}
```

## 1.9 合并有序的链表：

```cpp
ListNode* mergeList(ListNode *pa, ListNode *pb)
{
    ListNode *pc = new ListNode();
    ListNode *LC = pc;

    pa = pa->next;
    pb = pb->next;

    while (pa != nullptr && pb != nullptr) {
        if (pa->val <= pb->val) {
            pc->next = new ListNode(pa->val);
            pa = pa->next;
            pc = pc->next;
        }
        else {
            pc->next = new ListNode(pb->val);
            pb = pb->next;
            pc = pc->next;
        }
    }
    return LC;
}
```

## 1.10 求有序链表的交集：

```cpp
ListNode* joinTwoList(ListNode *pa, ListNode *pb)
{
    ListNode *pc = new ListNode();
    ListNode *LC = pc;

    pa = pa->next;
    pb = pb->next;
    while (pa != nullptr && pb != nullptr) {
        if (pa->val < pb->val) {
            pa = pa->next;
        }
        else if (pa->val > pb->val) {
            pb = pb->next;
        }
        else {
            pc->next = new ListNode(pa->val);

            pc = pc->next;
            pa = pa->next;
            pb = pb->next;
        }
    }
    delete pa;
    delete pb;
    return LC;
}
```

## 1.12 双向链表：

```c
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>

typedef int ElemType;

typedef struct DuLNode
{
    ElemType data;
    struct DuLNode *prior;
    struct DuLNode *next;
} DuLNode, *DuLinkList;

bool ListInit(DuLNode *head)
{
    head = (DuLNode *)malloc(sizeof(DuLNode));
    head->next = NULL;
    head->prior = NULL;
    head->data = 0;

    return true;
}

DuLNode *getElem(DuLNode *head, int index)
{
    DuLNode *rear = (DuLNode *)malloc(sizeof(DuLNode));
    rear = head;
    if (rear->next == NULL)
    {
        printf("is empty list!\n");
        exit(0);
    }

    // rear = rear->next;
    while (rear != NULL && index > 0)
    {
        rear = rear->next;
        index--;
    }
    return rear;
}

bool CreateListByRear(DuLNode *head, int num)
{
    DuLNode *rear = (DuLNode *)malloc(sizeof(DuLNode));

    rear = head;
    int i = 0;
    int data = 0;

    for (i = 0; i < num; i++)
    {
        printf("请输入第%d个数:", i);
        scanf("%d", &data);

        DuLNode *newNode = (DuLNode *)malloc(sizeof(DuLNode));

        newNode->data = data;
        newNode->next = NULL;
        newNode->prior = NULL;

        rear->next = newNode;
        newNode->prior = rear;
        rear = rear->next;
    }
    return true;
}

bool ListInsert(DuLNode *head, ElemType value, int index)
{
    DuLNode *indexNode = (DuLNode *)malloc(sizeof(DuLNode));
    DuLNode *newNode = (DuLNode *)malloc(sizeof(DuLNode));
    if (head->next == NULL)
    {
        return false;
    }

    indexNode = getElem(head, index - 1);

    newNode->data = value;
    newNode->prior = NULL;
    newNode->next = NULL;

    newNode->next = indexNode->next;
    newNode->prior = indexNode;
    indexNode->next = newNode;

    return true;
}

// int ListDelete(DuLNode *head, int index)
// {
//     int returnVal = -1;
//     DuLNode *indexNode = (DuLNode *)malloc(sizeof(DuLNode));
//     DuLNode *delNode = (DuLNode *)malloc(sizeof(DuLNode));
//     if (head->next == NULL)
//     {
//         return false;
//     }

//     indexNode = getElem(head, index - 1);

//     delNode = indexNode->next;
//     returnVal = delNode->data;

//     delNode->next->prior = delNode->prior;
//     indexNode->next = delNode->next;

//     free(delNode);
//     return returnVal;
// }
int ListDelete(DuLNode *head, int index)
{
    int returnVal = -1;
    DuLNode *delNode = (DuLNode *)malloc(sizeof(DuLNode));
    if (head->next == NULL)
    {
        return false;
    }

    delNode = getElem(head, index);
    returnVal = delNode->data;

    if (delNode->next == NULL)
    {
        free(delNode);
        return returnVal;
    }
    delNode->prior->next = delNode->next;
    delNode->next->prior = delNode->prior;

    free(delNode);
    return returnVal;
}

void printDoubleList(DuLNode *head)
{
    head = head->next;
    while (head != NULL)
    {
        printf("%d ", head->data);
        head = head->next;
    }
    printf("\n");
}

int main()
{
    int ret = -1;
    DuLNode *tmp = (DuLNode *)malloc(sizeof(DuLNode));
    DuLNode head;
    ListInit(&head);

    CreateListByRear(&head, 3);
    printDoubleList(&head);
    // tmp = getElem(&head, 2);
    // printf("ret= %d\n", tmp->data);

    ListInsert(&head, -1, 1);
    printDoubleList(&head);

    printf("%d\n", ListDelete(&head, 4));
    printDoubleList(&head);
    // printf("%d\n", ListDelete(&head, 1));
    // printf("%d\n", ListDelete(&head, 1));
    // printf("%d\n", ListDelete(&head, 1));

    return 0;
}
```

## 1.13 链表的排序（直接插入排序）：

```c
#include <stdio.h>
#include <stdlib.h>

typedef struct LNode {
    int data;
    struct LNode *next;
} LNode, *LinkList;

//尾插法创建链表
LNode *createListByRear(int nums) {
    LNode *head = (LNode *)malloc(sizeof(LNode));
    LNode *rear = (LNode *)malloc(sizeof(LNode));

    head->next = NULL;
    head->data = nums;
    rear = head;

    while (nums) {
        LNode *newNode = (LNode *)malloc(sizeof(LNode));
        printf("please input newNode->data:\n");
        scanf("%d", &newNode->data);
        newNode->next = NULL;

        rear->next = newNode;
        rear = newNode;
        nums--;
    }
    return head;
}

void printList(LNode *head) {
    head = head->next;
    while (head != NULL) {
        printf("%d ", head->data);
        head = head->next;
    }
    printf("\n");
}

void sort(LNode *head) {
    //临时节点，保存当前节点的下一个节点
    LNode *tmp = (LNode *)malloc(sizeof(LNode));
    //排序链表的当前节点
    LNode *cur = (LNode *)malloc(sizeof(LNode));
    //记录排序后链表的前一节点（cur->data > pre->data的上一节点）
    LNode *pre = (LNode *)malloc(sizeof(LNode));
    //保存有序的新链表
    LNode *newList = (LNode *)malloc(sizeof(LNode));

    newList->next = NULL;
    newList->data = 0;

    //将原链表的移动到下一个节点（不对头结点排序）
    head = head->next;

    while (head != NULL) {
        //暂存下一个节点（用来遍历和head = head->next 有着一样的效果）
        tmp = head->next;
        //待排序的单前节点，从第一个节点开始
        cur = head;
        //从有序的新链表的头部开始找
        pre = newList;

        //这里是寻找插入的位置（为了插入方便，我们找到插入位置的前一个位置）
        while (pre->next != NULL && cur->data > pre->next->data) {
            pre = pre->next;
        }
        //这里是插入
        cur->next = pre->next;
        pre->next = cur;

        //将head 移动至下一个节点（因为上面的cur->next 已经改变了，所以没有用head = head->next）
        head = tmp;
    }

    printf("-- -- -- -- -- -- -- -- --\n");
    printList(newList);
    printf("-- -- -- -- -- -- -- -- --\n");
}

int main() {
    LNode *head = (LNode *)malloc(sizeof(LNode));

    head = createListByRear(5);
    printList(head);

    sort(head);

    return 0;
}
```

## 1.14 删除链表中重复的元素：

```c
#include <stdio.h>
#include <stdlib.h>

typedef struct LNode {
    int data;
    struct LNode *next;
} LNode, *LinkList;

void printList(LNode *head) {
    while (head != NULL) {
        printf("%d ", head->data);
        head = head->next;
    }
    printf("\n");
}

LNode *createListByRear(int nums) {
    LNode *head = (LNode *)malloc(sizeof(LNode));
    LNode *rear = (LNode *)malloc(sizeof(LNode));
    int value = -1;

    head->next = NULL;
    head->data = nums;
    rear = head;

    while (nums) {
        LNode *newNode = (LNode *)malloc(sizeof(LNode));
        printf("please input newNode->data:\n");
        scanf("%d", &newNode->data);
        newNode->next = NULL;

        rear->next = newNode;
        rear = newNode;
        nums--;
    }
    return head;
}

void delSame(LNode *head) {
    LNode *pre = head->next;
    LNode *cur = pre->next;
    LNode *delNode = NULL;

    while (cur != NULL) {
        if (pre->data == cur->data) {
            delNode = cur;
            cur = cur->next;
            pre->next = delNode->next;

            free(delNode);
        } else {
            pre = pre->next;
            cur = cur->next;
        }
    }

    printf("-- -- -- -- -- -- -- -- --\n");
    printf("delSame\n");
    printList(head->next);
    printf("-- -- -- -- -- -- -- -- --\n");
}

int main() {
    LNode *head = (LNode *)malloc(sizeof(LNode));
    LNode *tmp = (LNode *)malloc(sizeof(LNode));

    head = createListByRear(10);

    delSame(head);

    return 0;
}
```



---

---

---

# 2. 字符串：

## 1.1 字符串的反转:

```cpp
/**************** 版本一 ****************/
//首尾交换
void reverseString(vector<char> &s) {
    int len = s.size();
    int left = 0, right = len - 1;

    while (left < right) {
        swap(s[left], s[right]);
        left++;
        right--;
    }
}

/**************** 版本二 ****************/
void reverseString(vector<char> &s)
{
    for (int i = 0, j = s.size() - 1; i < s.size() / 2; i++, j--)
    {
        swap(s[i], s[j]);
    }
}

```

## 1.2 替换字符串空格：

```cpp
class Solution {
public:
    string replaceSpace(string s) {
        int count = 0;
        int old_size = s.size();

        for (int i = 0; i < old_size; i++) {
            if (s[i] == ' ') {
                count++;
            }
        }
        s.resize(old_size + 2 * count);
        int new_size = s.size();

        for (int i = new_size - 1, j = old_size - 1; j < i; i--, j--) {
            if (s[j] == ' ') {
                s[i] = '0';
                s[i - 1] = '2';
                s[i - 2] = '%';

                i = i - 2;
            }
            else {
                s[i] = s[j];
            }
        }

        return s;
    }
};
```

## 1.3 KMP算法实现：

```cpp
/**************** 获取next表(前缀表) ****************/
void getNext(int *next, string s) {
    int j = 0;
    next[0] = 0;

    for (int i = 1; i < s.size(); i++) {
        while (j > 0 && s[j] != s[i]) {
            j = next[j - 1];
        }

        if (s[i] == s[j]) {
            j++;
        }
        next[i] = j;
    }
}

/**************** 求解 ****************/
int strStr(string haystack, string needle) {
    if (needle.size() == 0) {
        return 0;
    }
    int next[needle.size()];
    getNext(next, needle);

    int j = 0;
    for (int i = 0; i < haystack.size(); i++) {
        while (j > 0 && haystack[i] != needle[j]) {
            j = next[j - 1];
        }
        if (haystack[i] == needle[j]) {
            j++;
        }
        if (j == needle.size()) {
            return (i - needle.size() + 1);
        }
    }
    return -1;
}
```

## 1.4 BF算法：

```cpp
int indexBF(string s, string t, int pos) {
    int j = 0;

    for (int i = pos; i < s.size();) {
        if (s[i] == t[j]) {
            i++;
            j++;
        }
        else if (s[i] != t[j]) {
            i = i - j + 1;
            j = 0;
        }

        if (j >= t.size()) {
            return i - j;
        }
    }
    return -1;
}
```

# 3. 顺序栈和链栈：

## 3.2 顺序栈：

![顺序栈](https://gitee.com/lmypotato/Image/raw/master//img/%E9%A1%BA%E5%BA%8F%E6%A0%88.png)

```c
/*************** 顺序栈 **************/
#include <stdio.h>		
#include <stdlib.h>		//malloc free
#include <stdbool.h>	//bool

#define MAX_SIZE 100	 //最长容量
#define OK 1			//成功返回值
#define ERROR 0			//失败返回值

typedef struct
{
    int *base;	//栈底
    int *top;	//栈顶
    int stackSize;
} sqStack;
//初始化栈
int stackInit(sqStack *stack)
{
    stack->base = (int *)malloc(sizeof(int) * MAX_SIZE);
    stack->stackSize = MAX_SIZE;
    stack->top = stack->base;

    return OK;
}
//压入栈(从数组的右边压入数据)
void push(sqStack *stack, int val)
{
    if (stack->top - stack->base == stack->stackSize)
    {
        printf("顺序栈已满!\n");
        return;
    }

    *(stack->top) = val;
    stack->top++;
}
//弹出(从数组的右边弹出元素)
int pop(sqStack *stack)
{
    int element = -99;

    if (stack->top == stack->base)
    {
        printf("顺序栈为空!\n");
        return ERROR;
    }

    stack->top--;
    element = *(stack->top);

    return element;
}
//取栈顶
int top(sqStack *stack)
{
    int element = -1;
    if (stack->top != stack->base)
    {
        element = *(stack->top - 1);
    }

    return element;
}
//是否为空
bool empty(sqStack *stack)
{
    return (stack->top == stack->base);
}

int main()
{
    sqStack s;

    stackInit(&s);

    push(&s, 1);
    push(&s, 2);

    printf("%d\n", empty(&s));

    printf("%d\n", top(&s));

    pop(&s);
    pop(&s);
    printf("%d\n", top(&s));

    printf("%d\n", empty(&s));

    system("pause");
    return 0;
}
```

## 3.2 链栈:

```c
/*************** 链栈(带头结点的链栈) **************/
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>

typedef struct stackNode
{
    int val;
    struct stackNode *next;
} stackNode, *linkStack;
//初始化，并返回一个stackNode *
linkStack stackInit()
{
    linkStack s = (stackNode *)malloc(sizeof(stackNode));
    s->next = NULL;

    return s;
}
//push 操作其实是链表的【头插法】，因为头插法的时候，数据是升序的(1, 2, 3...),但是插入后的结果是相反的
//这就和栈一样(先进后出 【FILO】)
void push(linkStack stack, int val)//头插法
{
    linkStack head = stack;
	//创建新节点
    linkStack tmp = (stackNode *)malloc(sizeof(stackNode));
    tmp->val = val;
	
    tmp->next = head->next;
    head->next = tmp;
}
//因为数据已经是符合栈的操作的(假设输入为：1, 2, 3  构建后栈为 【头节点】, 3, 2, 1)
//所以就相当于遍历链表(把头节点的指针往后移动 + 删除遍历过的节点)
int pop(linkStack *stack)
{
    if ((*stack)->next == NULL)
    {
        printf("stack is NULL\n");
        return -99;
    }
    int element = -99;

    linkStack tmp = (stackNode *)malloc(sizeof(stackNode));

    element = (*stack)->next->val;
    tmp = *stack;
    *stack = (*stack)->next;

    free(tmp);

    return element;
}
//返回栈顶(即要弹出的数据)
int top(linkStack stack)
{
    if (stack->next == NULL)
    {
        printf("stack is NULL\n");
        return -99;
    }
    return stack->next->val;
}
//如果栈为空，返回1
//如果栈不为空，返回0
bool empty(linkStack stack)
{
    return stack->next == NULL;
}

int main()
{
    linkStack s;

    s = stackInit();

    push(s, 1);
    push(s, 2);
    push(s, 3);

    printf("list %d\n", empty(s));
    printf("%d\n", pop(&s));
    printf("%d\n", pop(&s));
    printf("%d\n", pop(&s));
    printf("list %d\n", empty(s));
    printf("%d\n", top(s));

    return 0;
}
```

## 3.3 顺序队列：(循环队列)

![](https://gitee.com/lmypotato/Image/raw/master//img/%E9%A1%BA%E5%BA%8F%E9%98%9F%E5%88%97.png)

```c
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>

#define MAX_SIZE 100

typedef struct
{
    int *base;
    int rear;
    int front;
} sqQueue;

void sqQueueInit(sqQueue *q)
{
    q->base = (int *)malloc(sizeof(int) * MAX_SIZE);
    q->rear = q->front = 0;
}

void push(sqQueue *q, int val)
{
    int size = (q->rear - q->front + MAX_SIZE) % MAX_SIZE;

    if (size >= MAX_SIZE)
    {
        return;
    }

    q->base[q->rear] = val;
    q->rear = (q->rear + 1) % MAX_SIZE;
}

int pop(sqQueue *q)
{
    if (q->rear == q->front)
    {
        printf("顺序队列为空!\n");
        return -1;
    }
    int element = -99;

    element = q->base[q->front];
    q->front = (q->front + 1) % MAX_SIZE;

    return element;
}

int top(sqQueue q)
{
    if (q.rear == q.front)
    {
        return -99;
    }
    return q.base[q.front];
}

bool empty(sqQueue q)
{
    return q.front == q.rear;
}

int main()
{
    sqQueue queue;

    sqQueueInit(&queue);

    printf("queue is %d\n", empty(queue));

    push(&queue, 1);
    push(&queue, 2);
    push(&queue, 3);

    printf("queue is %d\n", empty(queue));
    printf("top is %d\n", top(queue));

    printf("%d\n", pop(&queue));
    printf("%d\n", pop(&queue));
    printf("%d\n", pop(&queue));

    printf("queue is %d\n", empty(queue));
    printf("top is %d\n", top(queue));

    return 0;
}
```

## 3.4 链队列:

```c
//带头结点的链队列
//链队列：从队尾插入元素，从队头弹出元素
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>

typedef struct qNode
{
    int val;
    struct qNode *next;
} qNode, *queuePtr;

typedef struct
{
    queuePtr rear;
    queuePtr front;
} linkQueue;

void queueInit(linkQueue *q)
{
    q->front = q->rear = (queuePtr)malloc(sizeof(qNode));

    q->rear->next = NULL;
    q->front->next = NULL;
}
//链队列：【FIFO】
//链队列的添加元素其实是和链表的【尾插法】一样(插入的元素的顺序是怎么样的就是怎么样的)
void push(linkQueue *q, int val)
{
    qNode *newNode = (qNode *)malloc(sizeof(qNode));
    newNode->next = NULL;
    newNode->val = val;

    q->rear->next = newNode;
    q->rear = newNode;
}
//和链表的遍历是一样的道理
int pop(linkQueue *q)
{
    int element = -99;
    if (q->front == q->rear)
    {
        printf("queue is empty!\n");
        return -99;
    }

    qNode *delNode = (qNode *)malloc(sizeof(qNode));
    delNode->next = NULL;
	//要弹出节点为：头节点连接的下一个元素
    delNode = q->front->next;
    element = delNode->val;
	//当要删除的元素是队列中的最后一个时(将链队列的 【对头】 和 【队尾】 置相等)
    if (q->rear == delNode)
    {
        q->rear = q->front;
    }
	//头节点的下一个元素是：要弹出元素的下一个元素
    q->front->next = delNode->next;
    free(delNode);

    return element;
}
//其实是取链表中的头节点(头结点不赋值)的下一个元素
int top(linkQueue q)
{
    int topNode = -99;

    if (q.front->next == q.rear->next)
    {
        printf("top: queue is empty\n");
        return -99;
    }

    return q.front->next->val;
}

bool empty(linkQueue q)
{
    return q.front->next == q.rear->next;
}

int main()
{
    linkQueue queue;

    queueInit(&queue);

    printf("empty:queue is %d\n", empty(queue));
    push(&queue, 1);
    push(&queue, 2);
    push(&queue, 3);

    printf("empty:queue is %d\n", empty(queue));

    printf("top is %d\n", top(queue));

    printf("pop is %d\n", pop(&queue));
    printf("pop is %d\n", pop(&queue));
    printf("pop is %d\n", pop(&queue));
    printf("pop is %d\n", pop(&queue));

    printf("empty:queue is %d\n", empty(queue));
    printf("top is %d\n", top(queue));

    return 0;
}
```

# 4. 递归三要素：（引用自代码随想录）

1. 确定递归函数的参数和返回值：
   	确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数，并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。
2. 确定终止条件：
       写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。
3. 确定单层递归的逻辑：
       确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。
4. 如果需要遍历整棵树，递归函数就不能有返回值。如果需要遍历某一条固定路线，递归函数就一定要有返回值！
5. 如果需要搜索整棵二叉树且不用处理递归返回值，递归函数就不要返回值。（这种情况就是本文下半部分介绍的113.路径总和ii）
6. 如果需要搜索整棵二叉树且需要处理递归返回值，递归函数就需要返回值。 （这种情况我们在[236. 二叉树的最近公共祖先](https://gitee.com/link?target=https%3A%2F%2Fprogrammercarl.com%2F0236.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88.html)中介绍）
7. 如果要搜索其中一条符合条件的路径，那么递归一定需要返回值，因为遇到符合条件的路径了就要及时返回。（本题的情况）

# 5. 二叉树：

```c
#include <stdio.h>
#include <stdlib.h>

typedef struct biNode
{
    char val;
    struct biNode *lChild, *rChild;
} biNode, *biTree;

void treeInit(biTree *t)
{
    //(*t) = (biTree)malloc(sizeof(biNode));
    *t = NULL;
}

void creatTree(biTree *t)
{
    char ch;
    scanf("%c", &ch);

    if (ch == '#')
    {
        *t = NULL;
    }
    else
    {
        *t = (biTree)malloc(sizeof(biNode));
        (*t)->val = ch;
        creatTree(&(*t)->lChild);
        creatTree(&(*t)->rChild);
    }
}

void preOrederTraverse(biTree t)
{
    if (t != NULL)
    {
        printf("%c ", t->val);
        preOrederTraverse(t->lChild);
        preOrederTraverse(t->rChild);
    }
    else
    {
        printf(" NULL ");
    }
}
// 12##3##
int main()
{
    biTree t;
    treeInit(&t);
    preOrederTraverse(t);
    creatTree(&t);
    preOrederTraverse(t);
    printf("\n");

    system("pause");

    return 0;
}
```

## 5.1 前序遍历（迭代法【利用栈】）:

```c++
vector<int> preorderTraversal(TreeNode *root)
{
    vector<int> result = {};
    stack<TreeNode *> st;

    if (root == nullptr)
    {
        return {};
    }

    st.push(root);

    while (!st.empty())
    {
        TreeNode *tmp = st.top();
        st.pop();

        result.push_back(tmp->val);

        if (tmp->right != nullptr)
        {
            st.push(tmp->right);
        }
        if (tmp->left != nullptr)
        {
            st.push(tmp->left);
        }
    }

    return result;
}
```

## 5.2 中序遍历（迭代法）:

```c++
vector<int> inorderTraversal(TreeNode *root)
{
    vector<int> result = {};
    stack<TreeNode *> st;

    TreeNode *cur = root;

    while (cur != nullptr || !st.empty())
    {
        if (cur != nullptr)
        {
            st.push(cur);
            cur = cur->left;
        }
        else
        {
            cur = st.top();
            st.pop();

            result.push_back(cur->val);
            cur = cur->right;
        }
    }

    return result;
}
```

## 5.3 后序遍历（迭代法）:

```c++
vector<int> postorderTraversal(TreeNode* root) {
    stack<TreeNode*> st;
    vector<int> result;
    if (root == NULL) return result;
    st.push(root);
    while (!st.empty()) {
        TreeNode* node = st.top();
        st.pop();
        result.push_back(node->val);
        if (node->left) st.push(node->left); // 相对于前序遍历，这更改一下入栈顺序 （空节点不入栈）
        if (node->right) st.push(node->right); // 空节点不入栈
    }
    reverse(result.begin(), result.end()); // 将结果反转之后就是左右中的顺序了
    return result;
}
```

## 5.4 层序遍历（队列）:

```c++
vector<vector<int>> leverlOrder(TreeNode *root)
{
    queue<TreeNode *> que;
    vector<vector<int>> result;

    if (root == nullptr)
    {
        return {};
    }

    que.push(root);

    while (!que.empty())
    {
        int size = que.size();
        vector<int> ret;

        for (int i = 0; i < size; i++)
        {
            TreeNode *node = que.front();
            que.pop();
            ret.push_back(node->val);

            if (node->left)
            {
                que.push(node->left);
            }
            if (node->right)
            {
                que.push(node->right);
            }
        }
        result.push_back(ret);
    }
    return result;
}
```

## 5.5 二叉树的所有路径：

```cpp
//递归求解
class Solution {
public:
    void traversal(TreeNode *cur, vector<int> &path, vector<string> &result) {
        path.push_back(cur->val);
        if (cur->left == nullptr && cur->right == nullptr) {
            string sPath = "";

            for (int i = 0; i < path.size() - 1; i++) {
                sPath += to_string(path[i]);
                sPath += "->";
            }
            sPath += to_string(path[path.size() - 1]);
            result.push_back(sPath);
            return;
        }

        if (cur->left != nullptr) {
            traversal(cur->left, path, result);
            path.pop_back();
        }
        if (cur->right != nullptr) {
            traversal(cur->right, path, result);
            path.pop_back();
        }
    }
    vector<string> binaryTreePaths(TreeNode* root) {
        vector<string> result;
        vector<int> path;

        if (root == nullptr) {
            return result;
        }
        traversal(root, path, result);
        return result;
    }
};

//迭代法求解
class Solution {
public:
    vector<string> binaryTreePaths(TreeNode* root) {
        vector<string> result;
        stack<TreeNode *> st;
        stack<string> stPath;

        if (root == nullptr) {
            return result;
        }
        st.push(root);
        stPath.push(to_string(root->val));
        while (!st.empty()) {
            TreeNode *node = st.top();
            st.pop();

            string path = stPath.top();
            stPath.pop();

            if (node->left == nullptr && node->right == nullptr) {
                result.push_back(path);
            }

            if (node->right != nullptr) {
                st.push(node->right);
                stPath.push(path + "->" + to_string(node->right->val));
            }
            if (node->left != nullptr) {
                st.push(node->left);
                stPath.push(path + "->" + to_string(node->left->val));
            }
        }
        return result;
    }
};
```

## 5.6.  二叉树输出树状结构（单值）:

```cpp
/*
---1
-2---1
4-3-2-1

-------1------- 2^3 - 1
---2-------1--- 2^2 - 1 2^3
-4---3---2---1- 2^1 - 1
8-7-6-5-4-3-2-1 2^0 - 1

---------------1--------------- 2^4 - 1
-------2---------------1        2^3 - 1   2^4 - 1
---4-------3-------2-------1    2^2 - 1   2^3 - 1
-8---7---6---5---4---3---2---1  2^1 - 1   2^2 - 1
0-1-2-3-4-5-6-7-8-9-1-2-3-4-5-6 2^0 - 1   2^1 - 1
*/
/*
层数：4(level)          最后面的的可以不用输出
1    -------1-------    每一行的最前面依次为 2^(4 - 1) - 1 = 7    2^(4 - 2) - 1 = 3...
2    ---|-------|---
2    ---2-------3---    每个元素相隔 2^(4 - 1) - 1 = 7
3    -|---|---|---|-
3    -4---5---6---7-    每个元素相隔 2^(4 - 2) - 1 = 3
4    |-|-|-|-|-|-|-|
4    1-2-3-4-5-6-7-8    每个元素相隔 2^(4 - 3) - 1 = 1

       1
   |-------|
   2       3
 |---|   |---|
 4   5   6   7
|-| |-| |-| |-|
1 2 3 4 5 6 7 8

---1
-|---|
-2---3
|-| |-|
4 5 6 7
*/
#include <iostream>
#include <queue>
#include <vector>
#include <math.h>

using namespace std;

struct TreeNode {
	int val;
	TreeNode *left;
	TreeNode *right;
	TreeNode() : val(0), left(nullptr), right(nullptr) {}
	TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
	TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
};
//为了好看，将二叉树层数加一层
//#define frontSpace (pow(2, level - 1) - 1)
//#define underline (pow(2, level) - 1)
#define frontSpace (pow(2, level) - 1)
#define underline (pow(2, level + 1) - 1)

//获取一个数的长度
int getNumLen(int val) {
	int result = 0;

	do {
		result++;
		val = val / 10;
	} while (val != 0);

	return result;
}
//获取树的深度
int getDepth(TreeNode *root) {
	if (root == nullptr) {
		return 0;
	}

	int depth = 0;
	int leftDepth = getDepth(root->left);
	int rightDepth = getDepth(root->right);

	depth = max(leftDepth, rightDepth) + 1;

	return depth;
}
//打印一行符号
void printUnderline(char symbol, int num) {
	for (int i = 0; i < num; i++) {
		cout << symbol;
	}
}

//打印树型结构
//第一个参数相当于传入一个二维数组
void printTree(vector<vector<int>> v, TreeNode *root) {
	//记录二叉树的层数
	//为什么要减一，因为调用了levelOrderTraverse(TreeNode *root)后，root为多加一层
	int level = getDepth(root) - 1;

	for (int i = 0; i < v.size(); i++) {
		//头结点单独处理
		if (i == 0) {
			//输出最前面的空格
			printUnderline(' ', frontSpace); // printUnderline('*', pow(2, level - 1) -1);
			//第一行输出结束，换行
			cout << v[0][0] << endl;

			level--;
			//这里输出这个：|-------|
			printUnderline(' ', frontSpace); // printUnderline('*', pow(2, level - 1) - 1);
			cout << '|';

			printUnderline('-', underline); // printUnderline('-', pow(2, level) - 1);
			//输出|-------|结束，换行
			cout << '|' << endl;
			continue;
		}
		//遍历每一层
		printUnderline(' ', frontSpace); // printUnderline('*', pow(2, level -1) -1);
		for (int j = 0; j < v[i].size(); j++) {
			cout << v[i][j];

			printUnderline(' ', underline - getNumLen(v[i][j]) + 1); // printUnderline(' ', pow(2, level) -1 - getNumLen(v[i][j]) + 1);
		}
		//每一层结束，换行
		cout << endl;

		level--;
		//输出|-------|
		if (level != 0) {
			printUnderline(' ', frontSpace); // printUnderline('*', pow(2, level - 1) - 1);
			for (int k = 0; k < v[i].size(); k++) {
				cout << '|';
				printUnderline('-', underline); // printUnderline('-', pow(2, level) - 1);
				cout << '|';
				printUnderline(' ', underline); // printUnderline(' ', pow(2, level) - 1);
			}
			cout << endl;
		}
	}
	cout << endl;
}
//层序遍历
void levelOrderTraverse(TreeNode *root) {
	//利用队列，先进先出，从上到下，从左到右遍历
	queue<TreeNode *> que;
	//记录全部数据
	vector<vector<int>> result;
	//保存每一层的数据
	vector<int> tmp;
	//二叉树的层数
	int level = getDepth(root);
	int depth = level;

	if (root == nullptr) {
		return;
	}

	que.push(root);
	while (!que.empty()) {
		//记录每一层的数据个数
		int size = que.size();
		//由二叉树性质可知，每一层最多有2^(k - 1)个
		tmp.resize(pow(2, depth - level));

		for (int i = 0; i < size; i++) {
			TreeNode *node = que.front();
			que.pop();

			tmp[i] = node->val;
			//把二叉树构建成满的二叉树，下面的步骤就是构建满二叉树
			//为什么构建满二叉树，因为好遍历，不用考虑太多
			//满二叉树：有2^(level) - 1 个元素
			if (node->left != nullptr) {
				que.push(node->left);
			} else {
				node->left = new TreeNode(0);
				que.push(node->left);
			}

			if (node->right != nullptr) {
				que.push(node->right);
			} else {
				node->right = new TreeNode(0);
				que.push(node->right);
			}
		}
		level--;
		//把每一层的元素放入二维数组中去
		result.push_back(tmp);
		if (level <= 0) {
			break;
		}
	}
	printTree(result, root);
}
//前序创建树
void creatBiTree(TreeNode **T) {
	int ch;
	cin >> ch;
	if (ch == -1) {
		*T = NULL;
	} else {
		*T = new TreeNode;

		(*T)->val = ch;
		creatBiTree(&(*T)->left);
		creatBiTree(&(*T)->right);
	}
}

// 10 20 30 40 50 -1 -1 -1 -1 -1 -1
// 4 2 1 -1 -1 3 -1 -1 7 -1 -1
// 1 2 -1 4 -1 -1 3 -1 5 -1 -1
//  1 2 -1 -1 3 -1 -1
//  1 2 4 -1 -1 5 -1 -1 3 6 -1 -1 7 -1 -1
// 1 2 3 -1 -1 -1 -1
// 10 -1 20 -1 30 -1 -1
// 1 2 3 4 5 -1 -1 -1 -1 -1 -1
// 10 20 40 -1 -1 50 -1 -1 30 60 -1 -1 70 -1 -1
int main() {
	TreeNode *node;

	creatBiTree(&node);
	levelOrderTraverse(node);

	return 0;
}

```

# 6. 排序算法:

## 6.1 插入排序：

### 1. 直接插入排序：

```c
//版本一
void insertSort(int arr[], int len) {
	int i = 0, j = 0;
	int tmp = 0;

	for (i = 1; i < len; i++) {
		tmp = arr[i];
		for (j = i - 1; j >= 0; j--) {
			if (arr[j] > tmp) {
				arr[j + 1] = arr[j];
			}
			else {
				break;
			}
		}
		arr[j + 1] = tmp;
	}
}
//版本二：从小到大（升序）
void insertSort(int arr[], int len) {
	int i = 0, j = 0;
	int tmp = 0;
	//认为第一个数字为有序，从第二个数开始
	for (i = 1; i < len; i++) {
		//保存第二数（待插入元素）
		tmp = arr[i];
		for (j = i - 1; tmp < arr[j]; j--) {
		//如果待插入元素【小于】前一个元素，则把大的那个数的位置后移
			arr[j + 1] = arr[j];
		}
		//为什么是 j + 1，因为找到了待插入的位置后，【j--】，把待插入位置多减了1
		arr[j + 1] = tmp;
	}
}
```

### 2. 折半插入排序：

```c
void bInsertSort(int arr[], int len) {
	int i = 0, j = 0;
	int tmp = 0;
	int left = 0, right = 0, mid = 0;

	for (i = 1; i < len; i++) {
		tmp = arr[i];
		//认为0 到 i - 1 有序，利用二分查找来找待插入位置
		left = 0;
		right = i - 1;

		while (left <= right) {
			mid = (left + right) / 2;
			//待插入元素【小于】中间值，待插入元素在有序的左边
			if (tmp < arr[mid]) {
				right = mid - 1;
			}
			else {
				left = mid + 1;
			}
		}
        //（我试过<= left也是可以的）
        //为什么是right + 1，我的理解是，有序序列是【小到大】，如果待插入元素小于中间值，位置在左边，right--
        //如果待插入元素大于有序序列的最后一个，left++，right相当于--
		for (j = i - 1; j >= right + 1; j--) {
			//将找到待插入位置后的元素整体往后移动
			arr[j + 1] = arr[j];
		}
		//为什么是 j + 1，因为找到了待插入的位置后，j--，把待插入位置多减了1
		arr[j + 1] = tmp;
	}
}
```

### 3. 希尔排序：

```c
//和直接插入排序很类似
void shellInsertSort(int arr[], int len, int dk) {
	int i = 0, j = 0;
	int tmp = 0;

	for (i = dk; i < len; i++) {
		tmp = arr[i];

		for (j = i - dk; j >= 0 && tmp < arr[j]; j -= dk) {
			arr[j + dk] = arr[j];
		}
		arr[j + dk] = tmp;
	}
}

void shellSort(int arr[], int len) {
	int dk = len;

	while (1) {
		dk = dk / 3 + 1;

		shellInsertSort(arr, len, dk);
		if (dk == 1) {
			break;
		}
	}
}
```

## 6.2 交换排序：

### 1. 冒泡排序：

```c
//从小到大排序（升序）
void bubbleSort(int arr[], int len) {
	int i = 0, j = 0;
	int tmp = 0;
	//标记某一趟是否发生过交换
	int flag = 0;
	//两两交换要交换n - 1次
	for (i = 0; i < len - 1; i++) {
		flag = 0;
		//每进行一次，最大的元素都会在最后面，所以每次都要多减1
		for (j = 0; j < len - i - 1; j++) {
			//前一个元素和后一个元素比较，前一个比后一个大【交换】
			if (arr[j] > arr[j + 1]) {
				tmp = arr[j];
				arr[j] = arr[j + 1];
				arr[j + 1] = tmp;
				flag = 1;
			}
		}
		//如果没有发生交换，说明已经有序
		if (flag == 0) {
			break;
		}
	}
}
```

### 2. 快速排序：

```c
/*
1.选择待排序中的第一个元素作为枢轴，保存为 key ，另设left和right，指向上界和下界

2.从表的最右侧一次往左搜索，找到第一个关键字小于枢轴key的记录，将其移至left处。
具体操作：当left < right时，若right所指记录关键字大于等于key则向左移动right指针；否则将right所指记录与枢轴交换

3.从表的最左侧一次往右搜索，找到第一个关键字小于枢轴key的记录，将其移至right处。
具体操作：当left < right时，若right所指记录关键字大于等于key则向右移动left指针；否则将left所指记录与枢轴交换

4.重复2和3直至left和righ相等
*/
int partition(int arr[], int left, int right) {
	int key = arr[left];//做枢轴记录

	while (left < right) {
		while (left < right && arr[right] >= key) {
			right--;
		}
		//将比枢轴小的记录移动到左端
		arr[left] = arr[right];

		while (left < right && arr[left] <= key) {
			left++;
		}
		//将比枢轴记录大的移动到最右端
		arr[right] = arr[left];
	}
	//枢轴记录到空的位置
	arr[left] = key;
	//返回枢轴位置
	return left;
}

void quickSort(int arr[], int left, int right) {
	int pivotloc = 0;
	if (left < right) {//长度大于1
		//将arr【left，right】一分为二，pivotloc是枢轴位置
		pivotloc = partition(arr, left, right);
		quickSort(arr, left, pivotloc - 1);
		quickSort(arr, pivotloc + 1, right);
	}
}
```

## 6.3 选择排序：

### 1. 选择排序：

```c
/*
1. 第一趟从【0】开始，通过n-1次比较从n个记录中选出关键字最小记录，记为arr[min]，交换arr[0]和arr[min]

2. 第二趟从arr[1]开始，通过n-2次比较，从n-1个记录中选出关键字最小的记录记为arr[min]，交换arr[1]和arr[min]

3. 依次类推，经过n-1趟，排序成功
*/
void selectSort(int arr[], int len) {
	int i = 0, j = 0;
	int min;
	int tmp = 0;
	
	for (i = 0; i < len - 1; i++) {
        //每一次循环开始，认为无序序列的第一个为最小值
		min = i;
		for (j = i + 1; j < len; j++) {
            //记录最小值
			if (arr[j] < arr[min]) {
				min = j;
			}
		}
        //交换
		tmp = arr[i];
		arr[i] = arr[min];
		arr[min] = tmp;
	}
}
```

### 2. 树状选择排序(堆排序):

1. 大顶堆：每个结点的值都大于或等于其左右孩子结点的值

2. 小顶堆：每个结点的值都小于或等于其左右孩子结点的值
3. 步骤：
   1. 从arr【2s】和arr【2s + 1】中选出较大者，假设arr【2s】的关键字较大，比较arr【s】和arr【2s】的关键字
   2. 若arr【s】>= arr【2s】,说明arr【s】为根的子树已经是堆了，不必做任何操作
   3. 若arr【s】< arr【2s】，交换arr【s】和arr【2s】。交换后，以arr【2s + 1】为根的子树仍是堆，如果以arr【2s】为根的子树不是堆，则重复上述过程，将以arr【2s】为根的子树调整为堆，直至运行到叶子结点为止。

```c
//大顶堆
//调整
void heapAdjust(int arr[], int s, int len) {
	//假设arr[s+1..len]，已经是堆了，将arr[s..len]为根的大根堆
	int key = arr[s];
	int j = 0;
	//沿key较大的孩子节点向下筛选
	for (j = 2 * s; j <= len; j *= 2) {
		//j为key较大的记录的下标
		if (j < len && arr[j] < arr[j + 1]) {
			j++;
		}
		
		//key应该插在arr[s]位置上
		if (key >= arr[j]) {
			break;
		}
		//如果key值小于其左右孩子中的一个，那么key值中的位置要放最大值
		//然后看原来最大值的位置的左右孩子与key值的比较
		arr[s] = arr[j];
		s = j;
	}
	//插入
	arr[s] = key;
}

//创建大根堆
void creatHeap(int arr[], int len) {
	int i = 0;
	for (i = len / 2; i > 0; i--) {
		heapAdjust(arr, i, len);
	}
}

void heapSort(int arr[], int len) {
	int i = 0;
	int tmp = 0;
	creatHeap(arr, len);

	for (i = len; i > 1; i--) {
		//将堆顶记录和当前未经排序子序列arr[1..i]中最后一个记录交换
		tmp = arr[1];
		arr[1] = arr[i];
		arr[i] = tmp;
		//将arr[1..i-1]重新调整为大根堆
		heapAdjust(arr, 1, i - 1);
	}
}
```

## 6.4 归并排序：

步骤:

1. 2-路归并排序将arr【left..right】中的记录归并排序后放入extra中。当序列长度等于1时，递归结束，否则：
2. 将当前序列一分为二，求出分裂点mid = （left + right）
3. 对子序列arr【left，mid】递归，进行归并排序，结果放入extra【0，right - left）中
4. 对子序列【mid，right】递归，进行归并排序，结果放入到extra【0，right - left）中
5. 调用算法merge，将有序的两个子序列extra【0，mid】和extra【mid，righ】归并为一个有序的序列

```c
void merge(int arr[], int left, int mid, int right) {
	int i = 0;
	int size = right - left;
	int index = 0;
	int leftIndex = left;
	int rightIndex = mid;
	//将arr中的记录从【left 到 right）并入到extra中去 
	int *extra = (int *)malloc(sizeof(int) * size);

	while (leftIndex < mid && rightIndex < right) {
		//如果左边的数小于右边的数，将小的记录到extra
		if (arr[leftIndex] < arr[rightIndex]) {
			extra[index++] = arr[leftIndex++];
		}
		else {
			extra[index++] = arr[rightIndex++];
		}
	}
	//如果左边还有数，说明，左边的一定比右边的大，然后并入extra
	while (leftIndex < mid) {
		extra[index++] = arr[leftIndex++];
	}
	//同上
	while (rightIndex < right) {
		extra[index++] = arr[rightIndex++];
	}
	//将有序的数组extra并入到left到right
	for (i = 0; i < size; i++) {
		arr[left + i] = extra[i];
	}
	free(extra);
}

void mergeSort(int arr[], int left, int right) {
	int mid = 0;

	//如果左边和右边相差一个值，说明两数相邻，到达了一个数
	if (left + 1 >= right) {
		return;
	}

	mid = (left + right) / 2;
	mergeSort(arr, left, mid);
	mergeSort(arr, mid, right);

	merge(arr, left, mid, right);
}

void merge_sort(int arr[], int len) {
	mergeSort(arr, 0, len);
}
```

## 6.5 基数排序：

```c
//求一个数是几位数，例如 999-> 3	100->2	1->1
int getMaxLen(int arr[], int len) {
	int i = 0;
	int maxLen = 0;
	int maxValue = -999;
	for (i = 0; i < len; i++) {
		if (arr[i] > maxValue) {
			maxValue = arr[i];
		}
	}

	while (maxValue != 0) {
		maxLen++;
		maxValue = maxValue / 10;
	}
	return maxLen;
}

void radixSort(int arr[], int len) {
	int i = 0;
	int j = 0;
	//记录要循环几次，如果最大数是两位数就要循环两次就可以排好序，如果最大值是三位数，就要循环三次就可以排好序
	int times = getMaxLen(arr, len);
	//索引：例如 index = 12 % 10 = 2
	int index = 0;
	//每一次循环会乘10，用来计算 个位，十位，百位...对应的值
	int radix = 1;
	//收集例如 val = 11, 11， 12，那么 dis[11/radix % 10] -> dis[1]++,dis[11/radix % 10] -> dis[1]++,dis[12/radix % 10] -> dis[2]++
	int distribute[10] = { 0 };
	//收集存储每一次分配后的序列值，相当于用来存储 arr
	int *collect = (int *)malloc(sizeof(int) * len);

	for (i = 0; i < times; i++) {
		//初始化次数为0
		for (j = 0; j < 10; j++) {
			distribute[j] = 0;
		}
		//第一遍统计每一个数，个位相同的个数，以及不同的个数
		//第二遍...十位
		for (j = 0; j < len; j++) {
			index = (arr[j] / radix) % 10;
			distribute[index]++;
		}
		//下面两步是比较难理解的一步，建议调试
		//在线可视化代码调试平台https://pythontutor.com/visualize.html#mode=edit
/*
因为distribute一直为10个数，这里是统计每一个数前面应该要留多大的位置给前一个数，例如
数组： 1 1 2 2 3 dis[0] = 0,dis[1] = 2, dis[2] = 2,dis[3] = 1, dis[4] = 0, dis[5] = 0...
进行下一步后 dis[0] = 0,dis[1] = 2, dis[2] = 4, dis[3] = 5, dis[4] = 5, dis[5] = 5...
*/
		for (j = 1; j < 10; j++) {
			distribute[j] = distribute[j] + distribute[j - 1];
		}
/*
将数组分配到收集数组中去，collect中部分会有序

collect[distribute[index] - 1] = arr[j];？
先遍历数组，假设数组为 1 1 2 2 3，
最后的dis数组为dis[0] = 0,dis[1] = 2, dis[2] = 4, dis[3] = 5, dis[4] = 5, dis[5] = 5...
当元素为1时，index= 1，找 dis[1]， collect[dis[1] - 1] = arr[0]， dis[1]-- = 1， collect【1】= 1
当元素为1时，index= 1，找 dis[1]， collect[dis[1] - 1] = arr[1]， dis[1]-- = 0， collect【0】= 1
当元素为2时，index= 2，找 dis[2]， collect[dis[2] - 1] = arr[2]， dis[2]-- = 3， collect【3】= 2
当元素为2时，index= 2，找 dis[2]， collect[dis[2] - 1] = arr[3]， dis[2]-- = 2， collect【2】= 2
当元素为3时，index= 3，找 dis[3]， collect[dis[3] - 1] = arr[4]， dis[3]-- = 4， collect【4】= 3
*/
		for (j = 0; j < len; j++) {
			index = (arr[j] / radix) % 10;
			collect[distribute[index] - 1] = arr[j];
			distribute[index]--;
		}
		radix = radix * 10;
	}
    
	for (j = 0; j < len; j++) {
		arr[j] = collect[j];
	}
	free(distribute);
	free(collect);
}
```

# 7. 查找算法：

## 7.1 顺序查找： 

```c
int searchBySeq(int arr[], int len, int target) {
	int i = 0;

	for (i = 0; i < len; i++) {
		if (arr[i] == target) {
			return i + 1;
		}
	}
	return -1;
}
```

##  7.2 二分查找：

```c
int searchByBinary(int arr[], int len, int target) {
	int left = 0;
	int right = len - 1;
	int mid = 0;
	//循环不变量，不变的量是左闭右闭
	while (left <= right) {
		mid = (left + right) / 2;
		//如果目标值比中间值小了，而且mid的值比较过了，
		//说明target的范围在 【left，mid - 1】
		if (target < arr[mid]) {
			right = mid - 1;
		}
		//如果目标值比中间值大了，而且mid的值比较过了，
		//说明target的范围在 【mid + 1，right】
		else if (target > arr[mid]) {
			left = mid + 1;
		}
		else {
			return mid + 1;
		}
	}
	return -1;
}
```

## 7.3 分块查找：

```c
#include <stdio.h>
#include <stdlib.h>

//分组后，每组的长度
#define GROUP_LEN 3

//数据表
typedef struct {
    int index; // 下标索引
    int key;   // 关键字
} elem;
//索引表
typedef struct {
    elem *IT;
    int length; //记录顺序表长度
} IndexTable;
//打印数组
void print(int arr[], int len) {
    int i = 0;

    for (i = 0; i < len; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");
}
//创建数组（包含输入数据）
int *creatArr(int len) {
    int i = 0;
    int *arr = (int *)malloc(sizeof(int) * len);

    printf("请输入一串数:\n");

    for (i = 0; i < len; i++) {
        scanf("%d", &arr[i]);
    }
    return arr;
}
//创建索引表
void creatIndexTable(int arr[], int len, IndexTable *indexTable) {
    int nums = len / GROUP_LEN; //索引表个数 = 数组长度 / 每组个数
    int i = 0, j = 0;
    int maxValue = -999; //记录最大值

    indexTable->IT = (elem *)malloc(sizeof(elem) * nums);
    indexTable->length = 0;
    //查找最大值
    for (i = 0; i < nums; i++) {
        for (j = i * (len / nums); j < (i + 1) * (len / nums); j++) {
            if (arr[j] > maxValue) {
                maxValue = arr[j];
            }
        }
        // j - 6 ？每一个索引表记录的是，每一个分组的最开始记录
        indexTable->IT[i].index = j - GROUP_LEN;
        indexTable->IT[i].key = maxValue;
        indexTable->length++;

        maxValue = -999;
    }
}
//打印索引表
void printIndexTable(IndexTable *it) {
    int i = 0;
    int len = it->length;

    for (i = 0; i < len; i++) {
        printf("index = %d, key = %d\n", it->IT[i].index, it->IT[i].key);
    }
}
//将索引表排序 （冒泡排序）
void sortIndexTable(IndexTable *it) {
    int i = 0;
    int j = 0;
    int len = it->length;
    elem tmp;

    for (i = 0; i < len - 1; i++) {
        for (j = 0; j < len - i - 1; j++) {
            if (it->IT[j].key > it->IT[j + 1].key) {
                tmp = it->IT[j];
                it->IT[j] = it->IT[j + 1];
                it->IT[j + 1] = tmp;
            }
        }
    }
}
//二分查找
int searchByBinary(IndexTable it, int target) {
    int left = 0;
    int right = it.length - 1;
    int mid = 0;

    while (left <= right) {
        mid = (left + right) / 2;

        if (target < it.IT[mid].key) {
            right = mid - 1;
        } else if (target > it.IT[mid].key) {
            left = mid + 1;
        } else {
            return it.IT[mid].index;
        }
    }
    return it.IT[right + 1].index;
}
//顺序查找
int searchBySeq(int arr[], int start, int end, int target) {
    int i = 0;

    for (i = start; i < end; i++) {
        if (arr[i] == target) {
            return i;
        }
    }
    return -1;
}
//分块查找
int searchByBlock(int arr[], IndexTable it, int target) {
    int index = searchByBinary(it, target);
    int result = -2;

    result = searchBySeq(arr, index, index + GROUP_LEN, target);
    return result;
}
// 18数据
// 0  1  2  3 4 5  6  7  8  9  10 11 12 13 14 15 16 17
// 22 12 13 8 9 20 33 42 44 38 24 48 60 58 74 49 86 53
//  8 9 7 12 10 11 15 14 13 20 22 23 40 38 35 60 70 65
int main() {
    int *data = NULL;
    int result = -2;
    int target = 35;

    IndexTable it;

    data = creatArr(18);

    creatIndexTable(data, 18, &it);
    sortIndexTable(&it);
    printIndexTable(&it);

    result = searchByBlock(data, it, target);
    printf("result = %d\n", result);

    // system("pause");
    return 0;
}

```

## 7.4 二插排序树：

```c
#include <stdio.h>
#include <stdlib.h>

typedef struct TreeNode {
    int val;
    struct TreeNode *left;
    struct TreeNode *right;
} TreeNode;

void insertBST(TreeNode **t, int val) {
    if ((*t) == NULL) {
        TreeNode *newNode = (TreeNode *)malloc(sizeof(TreeNode));
        newNode->val = val;
        newNode->left = newNode->right = NULL;

        (*t) = newNode;
    } else if (val < (*t)->val) {
        insertBST(&(*t)->left, val);
    } else if (val > (*t)->val) {
        insertBST(&(*t)->right, val);
    }
}

void creatBST(TreeNode **root) {
    (*root) = NULL;
    int val = 0;

    scanf("%d", &val);
    while (val != -1) {
        insertBST(root, val);
        scanf("%d", &val);
    }
}

void preorderTraversal(TreeNode *root) {
    if (root != NULL) {
        preorderTraversal(root->left);
        printf("%d ", root->val);
        preorderTraversal(root->right);
    }
}

TreeNode* searchBST(TreeNode *root, int key) {
	if (root == NULL || key == root->val) {
		return root;
	}
	else if (key < root->val) {
		return searchBST(root->left, key);
	}
	else {
		return searchBST(root->right, key);
	}
}

int main() {
    TreeNode *node = NULL;

    creatBST(&node);
    preorderTraversal(node);
    printf("\n");

    system("pause");
    return 0;
}
```

## 7.5 平衡二插排序树：

!!!!!!!!!!简单理解的博客：[平衡二叉树](https://blog.csdn.net/isunbin/article/details/81707606?ops_request_misc=&request_id=&biz_id=102&utm_term=%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-7-81707606.first_rank_v2_pc_rank_v29&spm=1018.2226.3001.4187)

```c
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include "myfunction.h"

//typedef struct TreeNode {
//	int height;
//	int val;
//	struct TreeNode *left;
//	struct TreeNode *right;
//}TreeNode;

int height(TreeNode *root) {
	if (root == NULL) {
		return 0;
	}
	else {
		return root->height;
	}
}

TreeNode* newNode(int key) {
	TreeNode* node = (TreeNode*)malloc(sizeof(TreeNode));
	node->val = key;
	node->left = NULL;
	node->right = NULL;
	node->height = 1;
	return(node);
}

int getBalance(TreeNode* N) {
	if (N == NULL)
		return 0;
	return height(N->left) - height(N->right);
}

TreeNode * ll_rotate(TreeNode *y) {
	TreeNode *x = y->left;
	y->left = x->right;
	x->right = y;

	x->height = max(height(x->left), height(x->right)) + 1;
	y->height = max(height(y->left), height(y->right)) + 1;

	return x;
}

TreeNode* rr_rotate(TreeNode *y) {
	TreeNode *x = y->right;
	y->right = x->left;
	x->left = y;

	x->height = max(height(x->left), height(x->right)) + 1;
	y->height = max(height(y->left), height(y->right)) + 1;

	return x;
}

TreeNode* lr_rotate(TreeNode *y) {
	TreeNode *x = y->left;
	y->left = rr_rotate(x);

	return ll_rotate(y);
}

TreeNode* rl_rotate(TreeNode *y) {
	TreeNode *x = y->right;
	y->right = ll_rotate(x);
	return rr_rotate(y);
}


TreeNode* insert(TreeNode* node, int key)
{
	if (node == NULL) {
		return newNode(key);
	}

	if (key < node->val) {
		node->left = insert(node->left, key);
	}
	else if (key > node->val) {
		node->right = insert(node->right, key);
	}
	else {
		return node;
	}

	node->height =max(height(node->left), height(node->right)) + 1;

	int balance = getBalance(node);

	if (balance > 1 && key < node->left->val) {		//LL型
		return ll_rotate(node);
	}

	if (balance < -1 && key > node->right->val) {     //RR型
		return rr_rotate(node);
	}

	if (balance > 1 && key > node->left->val) {		//LR型
		node->left = rr_rotate(node->left);
		return ll_rotate(node);
	}

	if (balance < -1 && key < node->right->val) {    //RL型
		node->right = ll_rotate(node->right);
		return rr_rotate(node);
	}

	return node;
}

int main() {

	TreeNode *root = NULL;

	root = insert(root, 1);
	root = insert(root, 2);
	root = insert(root, 3);
	root = insert(root, 4);
	root = insert(root, 5);
	root = insert(root, 6);
	root = insert(root, 7);
	root = insert(root, 8);
	root = insert(root, 9);
	root = insert(root, 10);
	root = insert(root, 11);

	levelOrderTraverse(root);

//	system("pause");
	return 0;
}

```

## 7.6 B树：

详细教程链接：[B-树的详解](https://blog.csdn.net/qq_35644234/article/details/66969238?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164368726416780366590943%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=164368726416780366590943&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-11-66969238.first_rank_v2_pc_rank_v29&utm_term=B%E6%A0%91%E8%AF%A6%E8%A7%A3&spm=1018.2226.3001.4187)

### BTree.h

```cpp

/************************************************************/
/*                程序作者：Willam                          */
/*                程序完成时间：2017/3/28                   */
/*                有任何问题请联系：2930526477@qq.com       */
/************************************************************/
//@尽量写出完美的程序

#ifndef BMT_H_
#define BMT_H_


#include<iostream>
#include<cstdlib>
using namespace std;
#define m 3


typedef int KeyType;

typedef struct BMTNode {
    int keynum;
    BMTNode * parent;

    KeyType   key[m + 1];
    BMTNode * ptr[m + 1];

    BMTNode() : keynum(0), parent(NULL) {
        for (int i = 0; i <= m; ++i) {
            key[i] = 0;
            ptr[i] = NULL;
        }//endfor
    }//endctor
}*BMT;
typedef struct Node {
    int keynum;  //关键字的数量
    Node * parent;  //父亲结点
    KeyType key[m + 1]; //记录关键字，但是0号单元不用
    Node *  ptr[m + 1]; //记录孩子结点的指针
    Node() :keynum(0), parent(NULL) {
        for (int i = 0; i <= m; i++)
        {
            key[i] = 0;
            ptr[i] = NULL;
        }//endfor
    }//endcontruct
};

class BTree {
private:
    Node * head;
    int search(Node *& T, KeyType K); //查找关键字
    void insert(Node * & T, int i, KeyType K, Node * rhs); //插入关键字的位置
    bool split(Node *& T, int s, Node * & rhs, KeyType & midK); //结点分裂
    bool newroot(Node * & T, Node * & lhs, KeyType midK, Node * & rhs);
    void RotateLeft(Node * parent, int idx, Node * cur, Node * rsilb);
    void RotateRight(Node * parent, int idx, Node * cur, Node * lsilb);
    void Merge(Node * parent, int idx, Node * lsilb, Node * cur);
    void DeleteBalance(Node * curNode);
    void Delete(Node * curNode, int curIdx);
public:
    BTree();
    Node * gethead();
    bool searchKey_BTree(KeyType K, Node * & recNode, int & recIdx);
    bool insert_BTree(KeyType k);
    bool Delete_BTree(KeyType K);
    void Destroy(Node * & T);
    void WalkThrough(Node * & T);

};


#endif /* BMT_H_ */
```

### BTree.cpp

```cpp
#include"BTree.h"
BTree::BTree() {
    this->head = NULL;
}
//结点中，查找关键字序列，是否存在k，私有方法
int BTree::search(Node * & t,KeyType k) {
    int i = 0;
    for (int j = 1; j <= t->keynum; ++j) {
        if (t->key[j] <= k) {
            i = j;
        }
    }
    return i;
}

//遍历整个树，查找对应的关键字，公有方法，
bool BTree::searchKey_BTree(KeyType k, Node * & recNode, int & recIdx) {
    if (!head) {
        //cerr << "树为空" << endl;
        return false;
    }
    Node * p = head;
    Node * q = NULL;
    bool found = false;
    int i=0;
    while (p && !found) {
        i = this->search(p, k); //记住i返回两种情况：第一种是找到对应的关键字
        //第二次是找到了最后一个小于k的关键字下标（主要作用与插入时）
        if (i > 0 && p->key[i] == k) {
            //找到了记录结点和结点中关键字的下标
            recIdx = i;
            recNode = p;
            return true;
        }//endif
        else {
            recNode = p;         // 记录p的值，方便返回
            recIdx = i;
            p = p->ptr[recIdx]; // 查找下一个结点，
        }//endelse

    }//endw
    return false;
}
//这是在结点的关键字序列中，插入一个而关键字，私有方法
void BTree::insert(Node * & t, int i, KeyType k, Node * rhs) {
    //我们需要把关键字序列往后移动，然后插入新的关键字
    for (int j = t->keynum; j >= i + 1; --j) {
        t->key[j + 1] = t->key[j];
        t->ptr[j + 1] = t->ptr[j];
    }
    //插入新的关键字
    t->key[i + 1] = k;
    t->ptr[i + 1] = rhs;
    ++t->keynum;
}

//对对应的结点进行分裂处理,对t结点进行分裂处理，私有方法
bool BTree::split(Node * & t, int s, Node * & rhs, KeyType & midk) {
    rhs = new Node;
    //rhs为新建的结点，用于保存右半部分的。
    if (!rhs) {
        overflow_error;
        return false;
    }
    //我们们把t分裂的，所以rhs是t的兄弟结点，有相同的父母
    rhs->parent = t->parent;

    //其中关键字序列的中间值为
    midk = t->key[s];
    t->key[s] = 0;
    //这个通过画图，就可以知道rhs的0号孩子的指针，就是t的s号结点指针
    rhs->ptr[0] = t->ptr[s];

    //如果原来的t的s号孩子指针，现在的rhs的0号孩子指针不为空，则需要改变孩子的的父亲结点
    if (rhs->ptr[0]) {
        rhs->ptr[0]->parent = rhs;
    }//endif
    t->ptr[s] = NULL;
    for (int i = 1; i <= m - s; ++i) {
        //现在是把右半部分全部复制到到rhs中
        rhs->key[i] = t->key[s + i]; t->key[s + i] = 0;
        rhs->ptr[i] = t->ptr[s + i]; t->ptr[s + i] = NULL;
        //理由和刚才的理由一样
        if (rhs->ptr[i]) {
            rhs->ptr[i]->parent = rhs;
        }//endif
    }//endfor
    rhs->keynum = m - s;
    t->keynum = s - 1;
    return true;
}
//新建一个新的结点，私有方法
bool BTree::newroot(Node * & t, Node * & lhs, KeyType midk, Node * & rhs) {
    Node * temp = new Node;
    if (!temp) {
        overflow_error;
        return false;
    }
    temp->keynum = 1;
    temp->key[1] = midk;

    temp->ptr[0] = lhs;
    //左孩子不为空
    if (temp->ptr[0]) {
        temp->ptr[0]->parent = temp;
    }
    temp->ptr[1] = rhs;
    //右孩子不为空
    if (temp->ptr[1]) {
        temp->ptr[1]->parent = temp;
    }
    t = temp;
    return true;

}
//插入一个k（public方法）
bool BTree::insert_BTree(KeyType k) {
    Node * curNode = NULL;
    int preIdx = 0;
    if (this->searchKey_BTree(k, curNode, preIdx)) {
        cout << "关键已经存在" << endl;
        return false;
    }
    else {
        //没有找到关键字
        KeyType curk = k;
        Node * rhs = NULL;
        bool finished = false;
        while (!finished && curNode) {
            //不管是否合法，直接先插入刚才找到的那个关键字序列中
            this->insert(curNode, preIdx, curk, rhs);
            if (curNode->keynum < m) {//满足条件，直接退出
                finished = true;
            }
            else {
                int s = (m + 1) / 2;  //s为中间值的下标
                if (!this->split(curNode, s, rhs, curk)) {
                    //分裂失败，直接返回
                    return false;
                }
                if (curNode->parent == NULL) {
                    //如果curNode已经是根节点了，则可以直接退出了
                    break;
                }
                else {
                    //如果有那个父亲结点的话，此时curk指向的是原来这个结点中间值
                    //所以需要和父亲结点融合
                    curNode = curNode->parent;
                    preIdx = this->search(curNode, curk);
                }
            }
        }
        //如果head为空树，或者根结点已经分裂为结点curNode和rhs了，此时是肯定到了
        //根结点了
        if (!finished && !this->newroot(head, curNode, curk, rhs)) {
            cerr << "failed to create new root" << endl;
            exit(EXIT_FAILURE);
        }
    }
}

//删除结点k，找到合适的结点（public方法）
bool BTree::Delete_BTree(KeyType k) {
    Node * curNode = NULL;
    int curIdx = 0;
    if (this->searchKey_BTree(k, curNode, curIdx)) {
        this->Delete(curNode, curIdx);
        return true;
    }
    else {
        return false;
    }
}

//删除对应的进入结点，去删除关键字
void BTree::Delete(Node * curNode, int curIdx) {
    //curIdx不合法法时，直接返回
    if (curIdx<0 || curIdx>curNode->keynum) {
        return;
    }
    while (true) {//这里的步骤不是很清楚，等下来讨论
        //此时说明我们是处于非叶子结点
        if (curNode->ptr[curIdx - 1] && curNode->ptr[curIdx]) {

            //使用右子树中最小的关键字替换对应当前的关键的，然后删除那个最小的关键字
            Node * p1 = curNode->ptr[curIdx];
            while (p1->ptr[0]) {
                p1 = p1->ptr[0];
            }
            int res = p1->key[1];
            this->Delete_BTree(p1->key[1]);

            curNode->key[curIdx] = res;

            break;
        }
        else if (!curNode->ptr[curIdx - 1] && !curNode->ptr[curIdx])
        {   // is leaf
            for (int i = curIdx; i <= curNode->keynum; ++i) {
                curNode->key[i] = curNode->key[i + 1];
                // all ptr are NULL , no need to move.
            }//end for.
            --curNode->keynum;
            this->DeleteBalance(curNode);
            break;
        }
        else { //debug
            cerr << "Error" << endl;
        }
    }//endw
}
//删除对应关键字后，我们需要对删除后的树进行调整
void BTree::DeleteBalance(Node * curNode) {
    int lb = (int)m / 2;  
    Node * parent = curNode->parent;
    while (parent && curNode->keynum < lb) {//说明删除了关键字后，原来的那个结点已经不
        //符合B-树的最小结点要求，这个不懂可以回去看看条件
        int idx = 0;
        //找到curNode在其父亲节点中的位置
        for (int i = 0; i <= parent->keynum; ++i) {
            if (parent->ptr[i] == curNode) {
                idx = i;
                break;
            }
        }
        Node * lsilb = NULL; Node * rsilb = NULL;
        if (idx - 1 >= 0) {//如果当前结点有左兄弟
            lsilb = parent->ptr[idx - 1];
        }
        if (idx + 1 <= parent->keynum) {//说明当前结点有右兄弟
            rsilb = parent->ptr[idx + 1];
        }
        //只要右兄弟存在，而且满足rsilb->keynum > lb，即是删除的调整的情况2
        if (rsilb && rsilb->keynum > lb) {
            this->RotateLeft(parent, idx, curNode, rsilb);
            break;
        }//如果右兄弟不满足，而左兄弟满足，同样可以
        else if (lsilb && lsilb->keynum > lb) {
            this->RotateRight(parent, idx, curNode, lsilb);
            break;
        }//如果左右兄弟都不满足，那就是情况3了，
        else {
            //合并到左兄弟，
            if (lsilb)
                this->Merge(parent, idx, lsilb, curNode);
            else//没有左兄弟，合并到右兄弟
                this->Merge(parent, idx + 1, curNode, rsilb);
            // potentially causing deficiency of parent.
            curNode = parent;
            parent = curNode->parent;
        }
    }
    if (curNode->keynum == 0) {
        // root is empty,此时树为空
        head = curNode->ptr[0];
        delete curNode;
    }//endif
}
void BTree::RotateLeft(Node * parent, int idx, Node * cur, Node * rsilb) {
    //这个是在右兄弟存在的情况下，而且满足rsilb->keynum > lb，则我们需要从把
    //右兄弟结点中的最小关键字移动到父亲结点，而父亲结点中小于该右兄弟的关键字的关键字
    //就要下移到刚刚删除的那个结点中。

    //父亲结点中某个结点下移
    cur->key[cur->keynum + 1] = parent->key[idx + 1]; 
    cur->ptr[cur->keynum + 1] = rsilb->ptr[0];  //
    if (cur->ptr[cur->keynum + 1]) {
        cur->ptr[cur->keynum + 1]->parent = cur;    
    }
    rsilb->ptr[0] = NULL;

    ++cur->keynum;

    parent->key[idx + 1] = rsilb->key[1];
    rsilb->key[idx] = 0;
    //右兄弟上移一个结点到父亲结点，
    for (int i = 0; i <= rsilb->keynum; ++i) {//删除最靠右的那个结点
        rsilb->key[i] = rsilb->key[i + 1];
        rsilb->ptr[i] = rsilb->ptr[i + 1];
    }
    rsilb->key[0] = 0;
    --rsilb->keynum;
}
void BTree::RotateRight(Node * parent, int idx, Node * cur, Node * lsilb) {

    //这个是在左兄弟存在的情况下，而且满足lsilb->keynum > lb，则我们需要从把
    //左兄弟结点中的最大关键字移动到父亲结点，而父亲结点中大于该左兄弟的关键字的关键字
    //就要下移到刚刚删除的那个结点中。

    //因为是在左边插入
    for (int i = cur->keynum; i >= 0; --i) {//因为左边的都比右边小，所以要插入第一个位置
        cur->key[i + 1] = cur->key[i];
        cur->ptr[i + 1] = cur->ptr[i];
    }
    //在第一个位置插入父亲结点下移下来的结点
    cur->key[1] = parent->key[idx];
    cur->ptr[0] = lsilb->ptr[lsilb->keynum];

    if (cur->ptr[0])
        cur->ptr[0]->parent = cur;
    lsilb->ptr[lsilb->keynum] = NULL;
    ++cur->keynum;

    // from lsilb to parent.
    parent->key[idx] = lsilb->key[lsilb->keynum];
    lsilb->key[lsilb->keynum] = 0;
    --lsilb->keynum;

}
void BTree::Merge(Node * parent, int idx, Node * lsilb, Node * cur) {

    //函数实现都是往lsilb上合并，首先是先把cur中的剩余部分，全部合到左兄弟中个，
    for (int i = 0; i <= cur->keynum; ++i) {
        lsilb->key[lsilb->keynum + 1 + i] = cur->key[i];
        lsilb->ptr[lsilb->keynum + 1 + i] = cur->ptr[i];
        if (lsilb->ptr[lsilb->keynum + 1 + i])
            lsilb->ptr[lsilb->keynum + 1 + i] = lsilb;
   }
    //然后再把父亲结点中的idx对应的内容添加到左兄弟
    lsilb->key[lsilb->keynum + 1] = parent->key[idx];
    lsilb->keynum = lsilb->keynum + cur->keynum + 1;
    delete cur;
    //然后更新我们的父亲结点内容
    for (int i = idx; i <= parent->keynum; ++i) {
        parent->key[i] = parent->key[i + 1];
        parent->ptr[i] = parent->ptr[i + 1];
    }//end for.
    --parent->keynum;
}
void BTree::Destroy(Node * & T) { //释放空间
    if (!T) { return; }
    for (int i = 0; i <= T->keynum; ++i)
        Destroy(T->ptr[i]);
    delete T;
    T = NULL;
    return;
}
void BTree::WalkThrough(Node * &T) {
    if (!T) return;
    static int depth = 0;
    ++depth;
    int index = 0;

    bool running = true;

    while (running) {
        int ans = 0;
        if (index == 0) {
            ans = 2;
        }
        else {
            cout << "Cur depth: " << depth << endl;
            cout << "Cur Pos: " << (void*)T << ";  "
                << "Keynum: " << T->keynum << "; " << endl;
            cout << "Index: " << index << ";  Key: " << T->key[index] << endl;

            do {
                cout << "1.Prev Key; 2.Next Key; 3.Deepen Left; 4.Deepen Right; 5.Backup" << endl;
                cin >> ans;
                if (1 <= ans && ans <= 5)
                    break;
            } while (true);
        }


        switch (ans) {
        case 1:
            if (index == 1)
                cout << "Failed." << endl;
            else
                --index;
            break;
        case 2:
            if (index == T->keynum)
                cout << "Failed" << endl;
            else
                ++index;
            break;
        case 4:
            if (index > 0 && T->ptr[index])
                WalkThrough(T->ptr[index]);
            else
                cout << "Failed" << endl;
            break;
        case 3:
            if (index > 0 && T->ptr[index - 1])
                WalkThrough(T->ptr[index - 1]);
            else
                cout << "Failed" << endl;
            break;
        case 5:
            running = false;
            break;
        }//endsw
    }//endw

    --depth;
}
Node * BTree::gethead() {
    return this->head;
}

```

### main.cpp

```cpp

#include"BTree.h"

#define BMT_TEST
#ifdef BMT_TEST
//BMT: 10 45 24 53 90 3 37 50 61 70 100
int main(void)
{
    BTree t;

    int n;
    cout << "输入数的个数：" << endl;
    cin >> n;
    cout << "输入各个数的值：" << endl;
    for (int i = 0; i < n; i++) {
        int temp;
        cin >> temp;
        t.insert_BTree(temp);
    }
    Node * head = t.gethead();
    t.WalkThrough(head);

    int key;
    cout << "输入需要删除的值：" << endl;
    cin >> key;
    t.Delete_BTree(key);
    head = t.gethead();
    t.WalkThrough(head);

    return 0;
}
#endif
```

## 8. 图：

### 8.1 邻接矩阵：

```c
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>

//vertex 顶点
//arc 弧
#define MaxInt 32767	//表示极大值
#define MVNum 15		//最大顶点数
typedef int VerTexType;	//假设顶点数据为整数
typedef int ArcType;	//权值类型为整数
//记录访问过的节点（遍历使用）
bool visited[MVNum];

typedef struct {
	VerTexType vexs[MVNum];		//顶点表
	ArcType arcs[MVNum][MVNum];	//邻接矩阵
	int vexnum, arcnum;			//图当前顶点数和边数
}AMGraph;

//辅助空间（克鲁斯卡尔）
typedef struct Edge{
	VerTexType Head;	//边上的始点
	VerTexType Tail;	//边上的终点
	ArcType lowcost;	//边上的权值
}Edge;
Edge *edge[MVNum];

//Prim
struct {
	VerTexType adjvex;	//最小边在U上的那个顶点
	ArcType lowcost;	//最小边上的权值
}closedge[MVNum];


//查找v再顶点表的位置
int LocateVex(AMGraph *G, VerTexType v) {
	int i = 0;
	int index = 0;
	//在顶点表中查找顶点所在的位置
	for (i = 0; i < G->vexnum; i++) {
		if (G->vexs[i] == v) {
			index = i;
			return index;
		}
	}
	return index;
}
//创建邻接矩阵
bool CreateUDN(AMGraph *G) {
	int i = 0;
	int j = 0;
	int k = 0;
	int weight = 0;//权值
	VerTexType value1 = 0, value2 = 0;
	printf("请输入顶点数和总边数:\n");
	scanf_s("%d%d", &G->vexnum, &G->arcnum);

	printf("请输入各个顶点:\n");
	for (i = 0; i < G->vexnum; i++) {
		scanf_s("%d", &G->vexs[i]);
	}
	//初始化邻接矩阵，边的权值都为最大值
	for (i = 0; i < G->vexnum; i++) {
		for (j = 0; j < G->vexnum; j++) {
			G->arcs[i][j] = MaxInt;
		}
	}

	for (k = 0; k < G->arcnum; k++) {
		printf("请输入两个顶点和两个顶点之间的权值:\n");
		scanf_s("%d%d%d", &value1, &value2, &weight);
		//保存边
		edge[k]->Head = value1;
		edge[k]->Tail = value2;
		edge[k]->lowcost = weight;
		//确定value1和value2在顶点表中的位置，即顶点数组的下标
		i = LocateVex(G, value1);
		j = LocateVex(G, value2);
		//边<value1, value2>的权值为weight
		G->arcs[i][j] = weight;
		//无向图对称边也一样
		G->arcs[j][i] = G->arcs[i][j];
	}
	return true;
}
//打印二维数组
void PrintGraph(AMGraph G) {
	int i = 0, j = 0;

	for (i = 0; i < G.vexnum; i++) {
		for (j = 0; j < G.vexnum; j++) {
			if (G.arcs[i][j] == MaxInt) {
				printf("∞\t");
			}
			else {
				printf("%d\t", G.arcs[i][j]);
			}
		}
		printf("\n");
	}
	printf("\n");
}
//图G为邻接矩阵，从v个顶点出发，深度优先搜索遍历图G
void DFS_AM(AMGraph G, int v) {
	//访问第v个顶点，并置访问标志数组相应对应分量值为true
	int w = 0;
	printf("%d->", v);
	visited[v] = true;
	//一次检查邻接矩阵v所在的行
	for (w = 0; w < G.vexnum; w++) {
		//G.arcs[v][w] != 0表示w是v的邻接点，如果w未访问，则递归调用DFS_AM
		if ((G.arcs[v][w] != 0) && (!visited[w])) {
			DFS_AM(G, w);
		}
	}
}

int main() {
	AMGraph G;

	int i = 0;
	for (i = 0; i < 10; i++) {
		edge[i] = (Edge*)malloc(sizeof(Edge));
	}
	CreateUDN(&G);
	PrintGraph(G);
	printf("\n------------\n");
	DFS_AM(G, 0);
	printf("\n");
	ShortestPath_DIJ(G, 0);
	MinSpanTree_Kruskal(G);
	printf("\n------------\n");
	MinSpanTree_Prim(G, 1);
	printf("\n------------\n");
	Prim(G, 1);
	system("pause");
	return 0;
}
```

#### 8.11 迪杰斯特拉算法：

<img src="https://gitee.com/lmypotato/Image/raw/master//img/%E8%BF%AA%E6%9D%B0%E6%96%AF%E7%89%B9%E6%8B%891.png" alt="迪杰斯特拉1" style="zoom: 80%;" />

<img src="https://gitee.com/lmypotato/Image/raw/master//img/%E8%BF%AA%E6%9D%B0%E6%96%AF%E7%89%B9%E6%8B%89%E5%9B%BE.png" alt="迪杰斯特拉图" style="zoom:50%;" />

```c
void ShortestPath_DIJ(AMGraph G, int v0) {
	int n = G.vexnum;	//顶点个数
	int v = 0;
	int i = 0;
	int w = 0;
	int min = MaxInt;
	bool S[MVNum];
	int path[MVNum];
	int dis[MVNum];

	for (v = 0; v < n; v++) {
		S[v] = false;				//S初始化为空集
		dis[v] = G.arcs[v0][v];		//将v0到各个终点的最短路径长度初始化为弧长的权值
		if (dis[v] < MaxInt) {		
			path[v] = v0;			//如果v0和v之间有弧，则将v的前驱置为0
		}
		else {
			path[v] = -1;			//如果v0和v之间没有弧，则将v的前驱置为-1
		}
	}//for

	S[v0] = true;	//将v0加入s
	dis[v0] = 0;	//源点到源点的距离为0

	for (i = 1; i < n; i++) {	//对其余n-1个顶点，依次进行计算
		min = MaxInt;
		for (w = 0; w < n; w++) {
			if (!S[w] && dis[w] < min) {
				v = w;			//选择一条当前的最短路径，终点为v
				min = dis[w];	
			}
		}

		S[v] = true;
		for (w = 0; w < n; w++) {
			if (!S[w] && (dis[v] + G.arcs[v][w] < dis[w])) {
				dis[w] = dis[v] + G.arcs[v][w];		//更新dis【w】	
				path[w] = v;			//更新w的前驱为v
			}
		}
	}//for

	printf("dis:\n");
	for (i = 0; i < n; i++) {
		printf("%d->", dis[i]);
	}
	printf("\n");
}
```

#### 8.12 最小生成树：

##### 8.121 克鲁斯卡尔：

![](https://gitee.com/lmypotato/Image/raw/master//img/%E5%85%8B%E9%B2%81%E6%96%AF%E5%8D%A1%E5%B0%94.jpg)

```c
//冒泡排序（对权值）
void BubbleSort(int arcNum) {
	int i = 0;
	int j = 0;
	Edge *tmp = (Edge*)malloc(sizeof(Edge));

	for (i = 0; i < arcNum - 1; i++) {
		for (j = 0; j < arcNum - 1 - i; j++) {
			if (edge[j]->lowcost > edge[j + 1]->lowcost) {
				tmp = edge[j];
				edge[j] = edge[j + 1];
				edge[j + 1] = tmp;
			}
		}
	}
}
//最小生成树
void MinSpanTree_Kruskal(AMGraph G) {
	int i = 0, j = 0;
	int Vexset[MVNum];	//记录连通的点
	VerTexType v1, v2;
	VerTexType vs1, vs2;

	//按权值排序
	BubbleSort(G.arcnum);
	//辅助数组表示各顶点自成一个回路（连通分量）
	for (i = 0; i < G.vexnum; i++) {
		Vexset[i] = i;
	}

	for (i = 0; i < G.arcnum; i++) {	//依次查看数组edge中的边
		v1 = LocateVex(&G, edge[i]->Head);	//v1为边始结点的下标
		v2 = LocateVex(&G, edge[i]->Tail);
		vs1 = Vexset[v1];	//获取edge【i】的连通分量
		vs2 = Vexset[v2];

		if (vs1 != vs2) {	//边的两个顶点分属不同连通分量
			printf("%d->%d\n", edge[i]->Head, edge[i]->Tail);
		}
		//合并vs1和vs2两个连通分量
		for (j = 0; j < G.vexnum; j++) {
			if (Vexset[j] == vs2) {
				Vexset[j] = vs1;
			}
		}
	}//for
}
```

##### 8.122 普里姆算法：

<img src="https://gitee.com/lmypotato/Image/raw/master//img/prim.png" alt="prim" style="zoom:50%;" />

```cpp
//版本一
int Min(AMGraph G) {
    int i = 0;
    int index = 0;
    int min = MaxInt;
    for (i = 0; i < G.vexnum; i++) {
        if (closedge[i].lowcost < min
                && closedge[i].lowcost != 0) {
            min = closedge[i].lowcost;
            index = i;
        }
    }
    return index;
}

void MinSpanTree_Prim(AMGraph G, VerTexType u) {
    int k = LocateVex(&G, u);
    int i = 0, j = 0;
    int u0 = 0, v0 = 0;

    for (j = 0; j < G.vexnum; j++) {
        if (j != k) {
            //closedge[j] = {u, G.arcs[k][j]};
            closedge[j].adjvex = u;
            closedge[j].lowcost = G.arcs[k][j];
        }
    }
    closedge[k].lowcost = 0;

    for (i = 1; i < G.vexnum; i++) {
        k = Min(G);

        u0 = closedge[k].adjvex;
        v0 = G.vexs[k];
        printf("%d->%d\n", u0, v0);
        closedge[k].lowcost = 0;

        for (j = 0; j < G.vexnum; j++) {
            if (G.arcs[k][j] < closedge[j].lowcost) {
//                closedge[j] = { G.vexs[k], G.arcs[k][j] };
                closedge[j].adjvex = G.vexs[k];
            	closedge[j].lowcost = G.arcs[k][j];
            }
        }
    }
}
//版本二
void Prim(AMGraph G, int start) {
	int minValue = MaxInt;
	int i = 0, j = 0, k = 0;
	bool select[MVNum];	//记录选择的顶点
	int minDist[MVNum];	//储存一个顶点到其他顶点的权值
	int parent[MVNum];	//记录父亲节点，记录起始点的下标
	//分别记录找到最小权值边的末端顶点，与末端顶点相连的起始顶点
	int VexNode = 0, ParentNode = 0;
	//初始化
	for (i = 0; i < G.vexnum; i++) {
		select[i] = false;
		minDist[i] = MaxInt;
		parent[i] = -1;
	}
	//更新最短minDist中的权值和记录父亲节点
	for (i = 1; i < G.vexnum; i++) {
		select[start] = true;
		minValue = MaxInt;
		for (j = 0; j < G.vexnum; j++) {
			if (G.arcs[start][j] < minDist[j] && select[j] != true) {
				minDist[j] = G.arcs[start][j];
				parent[j] = start;
			}
		}
//查找最小值，如果最小顶点没有被加入，也就是select为false时
		for (k = 0; k < G.vexnum; k++) {
			if (minDist[k] < minValue && select[k] != true) {
				minValue = minDist[k];
				VexNode = k;
				ParentNode = parent[k];
			}
		}
		printf("%d->%d\n", ParentNode + 1, VexNode + 1);
		start = VexNode;//更新查找边的起始位置为最小权值边的末端
	}//最外层for
}
```



#### 8.13 测试数据：

```c
//------------------------------------------邻接矩阵-----------------------------
/*
迪杰斯特拉
6 8
0 1 2 3 4 5
0 2 10
0 4 30
0 5 100
1 2 5
2 3 50
3 5 10
4 3 20
4 5 60

else
3 3
1 2 3
1 3 2
1 2 1
2 3 1

普里姆/克鲁斯
6 10
1 2 3 4 5 6
1 2 6
1 3 1
1 4 5
2 5 3
2 3 5
3 5 6
3 6 4
3 4 5
4 6 2
5 6 6
*/
/*
如果支持中文(国家代码936), 可以用 printf("∞"); 
或者 putchar(161); putchar(222); 
如果不支持中文(国家代码437), 可以用 putchar(236);
*/
//---------------------------------------邻接表----------------------------------
/*
4 4
0 1 2 3
0 1
0 2
2 3
3 0

3 3
1 2 3
1 3
1 2
2 3
*/
```



### 8.2 邻接表：

```cpp
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <iostream>

using namespace std;

#define MVNum 5	//最大顶点数

bool visited[MVNum];

typedef int OtherInfo;	//其他数据
typedef int VertexType;	//顶点类型

typedef struct ArcNode {		//边节点
    int adjvex;					//该边所指向的顶点位置
    struct ArcNode *nextarc;	//指向下一条边的指针
    OtherInfo info;				//和边相关的信息（例如权值）
} ArcNode;

typedef struct VertexNode {		//顶点信息
    VertexType data;			//
    ArcNode *firstArc;			//指向第一条依附该顶点的边指针
} VertexNode, AdjList[MVNum];

typedef struct  {
    AdjList vertices;
    int vexNum, arcNum;		//图的当前顶点数和边数
} ALGraph;

//查找value在顶点表中的位置
int LocateVex(ALGraph *G, VertexType value) {
    int i = 0;
    int index = 0;

    for (i = 0; i < G->vexNum; i++) {
        if (G->vertices[i].data == value) {
            index = i;
            return index;
        }
    }
    return index;
}
//采用邻接表创建无向图
bool CreateUDG(ALGraph *G) {
    int i = 0;
    int j = 0;
    int k = 0;
    ArcNode *p1 = NULL, *p2 = NULL;
    VertexType v1 = 0, v2 = 0;
    printf("请输入总顶点数和总边数:\n");
    cin >> G->vexNum >> G->arcNum;
    //初始化
    for (i = 0; i < G->vexNum; i++) {
        cin >> G->vertices[i].data;
        G->vertices[i].firstArc = NULL;
    }
    //创建的是无向图
    for (k = 0; k < G->arcNum; k++) {
        //输入一条边依附的两个顶点
        cin >> v1 >> v2;

        i = LocateVex(G, v1);
        j = LocateVex(G, v2);

        p1 = new ArcNode;
        p1->adjvex = j;
        //利用头插法插入链表
        p1->nextarc = G->vertices[i].firstArc;
        G->vertices[i].firstArc = p1;

        p2 = new ArcNode;
        p2->adjvex = i;
        p2->nextarc = G->vertices[j].firstArc;
        G->vertices[j].firstArc = p2;
    }
    return true;
}

void printInfo(ALGraph G) {
    int i=0;
    for(i=0; i<G.vexNum; i++) {
        printf("G.vertices[i].data=%d->\n",G.vertices[i].data);
        while(G.vertices[i].firstArc!=NULL) {
            printf("%d->",G.vertices[i].firstArc->adjvex + 1);
            G.vertices[i].firstArc=G.vertices[i].firstArc->nextarc;
        }
        printf("\n");
    }
    printf("\n");
}

int main() {
    ALGraph G;

    CreateUDG(&G);
    printInfo(G);

    printf("\n");
    DFS_AL(G, 2);
    printf("\n");

    system("pause");
    return 0;
}
```

#### 8.21 深度优先遍历:

```cpp
//深度优先遍历
void DFS_AL(ALGraph G, int v) {
    ArcNode *p = new ArcNode;
    int w = 0;
    printf("%d->", v);
    visited[v] = true;
    //p指向v的边链表的第一个边结点
    p = G.vertices[v].firstArc;
    while (p != NULL) {//边结点非空
        //w表示v的邻接点
        w = p->adjvex;
        //如果w未访问，则递归调用
        if (visited[w] == 0) {
            DFS_AL(G, w);
        }
        //p指向下一个边节点
        p = p->nextarc;
    }//while
}
```

#### 8.22 广度优先遍历：

```cpp
//广度优先遍历
void BFS(ALGraph G, int v) {
	ArcNode *p;
	int u;
	LinkQueue queue;

	cout << v << "\t";
	visited[v] = true;

	InitQueue(&queue);//队列初始化
	push(&queue, v);

	while (!Empty(queue)) { //队列非空
		u = pop(&queue);
		p = G.vertices[u].firstArc;
		while (p != NULL) {
			if (visited[p->adjvex] == 0) { //如果p->adjvex未被访问过（该边所指向的顶点位置）
				cout << p->adjvex << "\t";
				visited[p->adjvex] = true;
				push(&queue, p->adjvex);
			}
			p = p->nextarc;
		}//if
	}//while
	printf("\n");
}
```

#### 8.23 拓扑排序：

```cpp
void FindInDegree(ALGraph G, int degree[]) {
	int i = 0;

	for (i = 0; i < G.vexNum; i++) {
		degree[i] = 0;
	}

	for (i = 0; i < G.vexNum; i++) {
		ArcNode *p = (ArcNode *)malloc(sizeof(ArcNode));
		p = G.vertices[i].firstArc;

		while (p != NULL) {
			degree[p->adjvex]++;
			p = p->nextarc;
		}
	}
}

bool TopologicalSort(ALGraph G, int topo[]) {
	int degree[MVNum];
	int i = 0;
	int m = 0;
	int value = 0;
	int tmp = 0;
	stack<int> s;
	FindInDegree(G, degree);

	for (i = 0; i < G.vexNum; i++) {
		if (degree[i] == 0) {
			s.push(i);//入度为0进栈
		}
	}

	while (!s.empty()) {
		tmp = s.top();
		s.pop();
		topo[m] = tmp;
		m++;

		ArcNode *p = G.vertices[tmp].firstArc;
		while (p != NULL) {
			value = p->adjvex;
			degree[value]--;
			if (degree[value] == 0) {
				s.push(value);//如入度为减为0，则进栈
			}
			p = p->nextarc;//p指向顶点vi下一个邻接
		}
	}
	if (m < G.vexNum) {
		printf("查找失败!\n");
		return false;
	}
	else {
		printf("OK\n");
		return true;
	}
}
```

#### 8.24 关键路径：

```cpp
bool CriticalPath(ALGraph G) {
	int ve[MVNum];
	int vl[MVNum];
	int topo[MVNum];
	int n = G.vexNum;	//顶点个数
	int e = 0, l = 0;
	ArcNode *p = (ArcNode *)malloc(sizeof(ArcNode));
	int i = 0, j = 0, k = 0;

	if (!TopologicalSort(G, topo)) {
		return false;
	}
	for (i = 0; i < n; i++) {
		ve[i] = 0;
	}

/*----------按拓扑排序求每个事件的最早发生事件----------*/
	for (i = 0; i < n; i++) {
		k = topo[i];
		p = G.vertices[k].firstArc;
		while (p != NULL) {
			j = p->adjvex;
			if (ve[j] < ve[k] + p->weight) {
				ve[j] = ve[k] + p->weight;
			}//if
			p = p->nextarc;
		}//while
	}//for
	for (i = 0; i < n; i++) {
		vl[i] = ve[n - 1];
	}
/*----------按逆拓扑排序求每个事件的最迟发生时间----------*/
	for (i = n - 1; i >= 0; i--) {
		k = topo[i];
		p = G.vertices[k].firstArc;
		while (p != NULL) {
			j = p->adjvex;
			if (vl[k] > vl[j] - p->weight) {
				vl[k] = vl[j] - p->weight;
			}//if
			p = p->nextarc;
		}//while
	}//for
/*----------判断每一活动是否为关键活动----------*/
	for (i = 0; i < n; i++) {
		p = G.vertices[i].firstArc;
		while (p != NULL) {
			j = p->adjvex;
			e = ve[i];
			l = vl[j] - p->weight;
			if (e == l) {
				cout << G.vertices[i].data << "-" << G.vertices[j].data<<endl;
			}//if
			p = p->nextarc;
		}//while
	}//for
}
```

#### 8.25 弗洛伊德算法：

```cpp

```

